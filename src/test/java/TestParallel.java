import Scheduler.*;
import org.graphstream.graph.Graph;

import org.graphstream.graph.Node;
import org.junit.Before;
import org.junit.Test;

import java.io.IOException;

import static org.junit.Assert.*;

public class TestParallel {

    private IOParser _parser;
    private int _numOfP;

    @Before
    public void initialiseIO() {
        _parser = new IOParser();
        _numOfP = 2;
    }

    CheckValidity checker = new CheckValidity();

    /**
     * This tests if the scheduled output graph generated by the 5Nodes7Edges.dot file is valid for single processor
     */
    @Test
    public void test5Node7EdgesSingleProcessor() throws IOException {

        Graph g = _parser.readDotFile("src/main/resources/graph/5Nodes7Edges.dot");
        GraphData testGraphData1 = new GraphData(g);
        GraphData testGraphData2 = new GraphData(g);

        ListScheduling listScheduling = new ListScheduling();

        int[] upperBoundAndLoadBalance = listScheduling.greedyAlgorithm(testGraphData1, _numOfP);
        //System.out.print(upperBoundAndLoadBalance[0] + "   " + upperBoundAndLoadBalance[1] +"\n");
        DFAlgorithmParallel test = new DFAlgorithmParallel(testGraphData2);
        Task[] finalResult = test.run(4, _numOfP, upperBoundAndLoadBalance[0], upperBoundAndLoadBalance[1]);

        for(int i = 0; i < finalResult.length; i++) {
            Node node = g.getNode(i);
            Task task = finalResult[i];

            node.setAttribute("Start", task.getStartTime());
            node.setAttribute("Processor", task.getProcessNum() + 1);
        }

        assertTrue(checker.checkValidity(g));
    }

    /**
     * This tests if the scheduled output graph generated by the 5Nodes7Edges.dot file is valid for 4 processors
     */
    @Test
    public void test5Node7Edges() throws IOException {

        Graph g = _parser.readDotFile("src/main/resources/graph/5Nodes7Edges.dot");
        GraphData testGraphData1 = new GraphData(g);
        GraphData testGraphData2 = new GraphData(g);

        ListScheduling listScheduling = new ListScheduling();

        int[] upperBoundAndLoadBalance = listScheduling.greedyAlgorithm(testGraphData1, _numOfP);
        //System.out.print(upperBoundAndLoadBalance[0] + "   " + upperBoundAndLoadBalance[1] +"\n");
        DFAlgorithmParallel test = new DFAlgorithmParallel(testGraphData2);
        Task[] finalResult = test.run(4, _numOfP, upperBoundAndLoadBalance[0], upperBoundAndLoadBalance[1]);

        for(int i = 0; i < finalResult.length; i++) {
            Node node = g.getNode(i);
            Task task = finalResult[i];

            node.setAttribute("Start", task.getStartTime());
            node.setAttribute("Processor", task.getProcessNum() + 1);
        }

        assertTrue(checker.checkValidity(g));
    }

    /**
     * This tests if the scheduled output graph generated by the 7Nodes9Edges.dot file is valid for 2 processors
     */
    @Test
    public void test7Node9Edges() throws IOException {

        Graph g = _parser.readDotFile("src/main/resources/graph/7Nodes9Edges.dot");
        GraphData testGraphData1 = new GraphData(g);
        GraphData testGraphData2 = new GraphData(g);

        ListScheduling listScheduling = new ListScheduling();

        int[] upperBoundAndLoadBalance = listScheduling.greedyAlgorithm(testGraphData1, _numOfP);
        //System.out.print(upperBoundAndLoadBalance[0] + "   " + upperBoundAndLoadBalance[1] +"\n");
        DFAlgorithmParallel test = new DFAlgorithmParallel(testGraphData2);
        Task[] finalResult = test.run(4, _numOfP, upperBoundAndLoadBalance[0], upperBoundAndLoadBalance[1]);

        for(int i = 0; i < finalResult.length; i++) {
            Node node = g.getNode(i);
            Task task = finalResult[i];

            node.setAttribute("Start", task.getStartTime());
            node.setAttribute("Processor", task.getProcessNum() + 1);
        }

        assertTrue(checker.checkValidity(g));

    }

    /**
     * This tests if the scheduled output graph generated by the Nodes_7_OutTree.dot file is valid for 2 processors
     */
    @Test
    public void test7NodeOutTree() throws IOException {
        Graph g = _parser.readDotFile("src/main/resources/graph/Nodes_7_OutTree.dot");
        GraphData testGraphData1 = new GraphData(g);
        GraphData testGraphData2 = new GraphData(g);

        ListScheduling listScheduling = new ListScheduling();

        int[] upperBoundAndLoadBalance = listScheduling.greedyAlgorithm(testGraphData1, _numOfP);
        //System.out.print(upperBoundAndLoadBalance[0] + "   " + upperBoundAndLoadBalance[1] +"\n");
        DFAlgorithmParallel test = new DFAlgorithmParallel(testGraphData2);
        Task[] finalResult = test.run(4, _numOfP, upperBoundAndLoadBalance[0], upperBoundAndLoadBalance[1]);

        for(int i = 0; i < finalResult.length; i++) {
            Node node = g.getNode(i);
            Task task = finalResult[i];

            node.setAttribute("Start", task.getStartTime());
            node.setAttribute("Processor", task.getProcessNum() + 1);
        }

        assertTrue(checker.checkValidity(g));

    }

    /**
     * This tests if the scheduled output graph generated by the Nodes_8_Random.dot file is valid for 2 processors
     */
    @Test
    public void test8NodeRandom() throws IOException {
        Graph g = _parser.readDotFile("src/main/resources/graph/Nodes_8_Random.dot");
        GraphData testGraphData1 = new GraphData(g);
        GraphData testGraphData2 = new GraphData(g);

        ListScheduling listScheduling = new ListScheduling();

        int[] upperBoundAndLoadBalance = listScheduling.greedyAlgorithm(testGraphData1, _numOfP);
        //System.out.print(upperBoundAndLoadBalance[0] + "   " + upperBoundAndLoadBalance[1] +"\n");
        DFAlgorithmParallel test = new DFAlgorithmParallel(testGraphData2);
        Task[] finalResult = test.run(4, _numOfP, upperBoundAndLoadBalance[0], upperBoundAndLoadBalance[1]);

        for(int i = 0; i < finalResult.length; i++) {
            Node node = g.getNode(i);
            Task task = finalResult[i];

            node.setAttribute("Start", task.getStartTime());
            node.setAttribute("Processor", task.getProcessNum() + 1);
        }

        assertTrue(checker.checkValidity(g));
    }

    /**
     * This tests if the scheduled output graph generated by the Nodes_9_SeriesParallel.dot file is valid for 4 processors
     */
    @Test
    public void test9NodeSeriesParallel() throws IOException {
        Graph g = _parser.readDotFile("src/main/resources/graph/Nodes_9_SeriesParallel.dot");
        GraphData testGraphData1 = new GraphData(g);
        GraphData testGraphData2 = new GraphData(g);

        ListScheduling listScheduling = new ListScheduling();

        int[] upperBoundAndLoadBalance = listScheduling.greedyAlgorithm(testGraphData1, _numOfP);
        //System.out.print(upperBoundAndLoadBalance[0] + "   " + upperBoundAndLoadBalance[1] +"\n");
        DFAlgorithmParallel test = new DFAlgorithmParallel(testGraphData2);
        Task[] finalResult = test.run(4, _numOfP, upperBoundAndLoadBalance[0], upperBoundAndLoadBalance[1]);

        for(int i = 0; i < finalResult.length; i++) {
            Node node = g.getNode(i);
            Task task = finalResult[i];

            node.setAttribute("Start", task.getStartTime());
            node.setAttribute("Processor", task.getProcessNum() + 1);
        }

        assertTrue(checker.checkValidity(g));

    }

    /**
     * This tests if the scheduled output graph generated by the Nodes_10_Random.dot file is valid for 2 processors
     */
    @Test
    public void test10NodeRandomTree() throws IOException {
        Graph g = _parser.readDotFile("src/main/resources/graph/Nodes_10_Random.dot");
        GraphData testGraphData1 = new GraphData(g);
        GraphData testGraphData2 = new GraphData(g);

        ListScheduling listScheduling = new ListScheduling();

        int[] upperBoundAndLoadBalance = listScheduling.greedyAlgorithm(testGraphData1, _numOfP);
        //System.out.print(upperBoundAndLoadBalance[0] + "   " + upperBoundAndLoadBalance[1] +"\n");
        DFAlgorithmParallel test = new DFAlgorithmParallel(testGraphData2);
        Task[] finalResult = test.run(4, _numOfP, upperBoundAndLoadBalance[0], upperBoundAndLoadBalance[1]);

        for(int i = 0; i < finalResult.length; i++) {
            Node node = g.getNode(i);
            Task task = finalResult[i];

            node.setAttribute("Start", task.getStartTime());
            node.setAttribute("Processor", task.getProcessNum() + 1);
        }

        assertTrue(checker.checkValidity(g));
    }

    /**
     * This tests if the scheduled output graph generated by the Nodes_11_OutTree.dot file is valid for 2 processors
     */
    @Test
    public void test11NodeOut() throws IOException {
        Graph g = _parser.readDotFile("src/main/resources/graph/Nodes_11_OutTree.dot");
        GraphData testGraphData1 = new GraphData(g);
        GraphData testGraphData2 = new GraphData(g);

        ListScheduling listScheduling = new ListScheduling();

        int[] upperBoundAndLoadBalance = listScheduling.greedyAlgorithm(testGraphData1, _numOfP);
        //System.out.print(upperBoundAndLoadBalance[0] + "   " + upperBoundAndLoadBalance[1] +"\n");
        DFAlgorithmParallel test = new DFAlgorithmParallel(testGraphData2);
        Task[] finalResult = test.run(4, _numOfP, upperBoundAndLoadBalance[0], upperBoundAndLoadBalance[1]);

        for(int i = 0; i < finalResult.length; i++) {
            Node node = g.getNode(i);
            Task task = finalResult[i];

            node.setAttribute("Start", task.getStartTime());
            node.setAttribute("Processor", task.getProcessNum() + 1);
        }

        assertTrue(checker.checkValidity(g));
    }

    /**
     * This tests if the scheduled output graph generated by the 1Node.dot file is valid for 2 processors
     */
    @Test
    public void test1Node() throws IOException {
        Graph g = _parser.readDotFile("src/main/resources/graph/1Node.dot");
        GraphData testGraphData1 = new GraphData(g);
        GraphData testGraphData2 = new GraphData(g);

        ListScheduling listScheduling = new ListScheduling();

        int[] upperBoundAndLoadBalance = listScheduling.greedyAlgorithm(testGraphData1, _numOfP);
        //System.out.print(upperBoundAndLoadBalance[0] + "   " + upperBoundAndLoadBalance[1] +"\n");
        DFAlgorithmParallel test = new DFAlgorithmParallel(testGraphData2);
        Task[] finalResult = test.run(4, _numOfP, upperBoundAndLoadBalance[0], upperBoundAndLoadBalance[1]);

        for(int i = 0; i < finalResult.length; i++) {
            Node node = g.getNode(i);
            Task task = finalResult[i];

            node.setAttribute("Start", task.getStartTime());
            node.setAttribute("Processor", task.getProcessNum() + 1);
        }

        assertTrue(checker.checkValidity(g));
    }

    /**
     * This tests if the scheduled output graph generated by the 5Nodes0Edges.dot file is valid for 2 processors
     */
    @Test
    public void test5Node0Edges() throws IOException {
        Graph g = _parser.readDotFile("src/main/resources/graph/5Nodes0Edges.dot");
        GraphData testGraphData1 = new GraphData(g);
        GraphData testGraphData2 = new GraphData(g);

        ListScheduling listScheduling = new ListScheduling();

        int[] upperBoundAndLoadBalance = listScheduling.greedyAlgorithm(testGraphData1, _numOfP);
        //System.out.print(upperBoundAndLoadBalance[0] + "   " + upperBoundAndLoadBalance[1] +"\n");
        DFAlgorithmParallel test = new DFAlgorithmParallel(testGraphData2);
        Task[] finalResult = test.run(4, _numOfP, upperBoundAndLoadBalance[0], upperBoundAndLoadBalance[1]);

        for(int i = 0; i < finalResult.length; i++) {
            Node node = g.getNode(i);
            Task task = finalResult[i];

            node.setAttribute("Start", task.getStartTime());
            node.setAttribute("Processor", task.getProcessNum() + 1);
        }

        assertTrue(checker.checkValidity(g));
    }

    /**
     * This tests if the scheduled output graph generated by the EmptyGraph.dot file is valid for 2 processors
     */
    @Test
    public void testEmptyGraph() throws IOException {
        Graph g = _parser.readDotFile("src/main/resources/graph/EmptyGraph.dot");
        GraphData testGraphData1 = new GraphData(g);
        GraphData testGraphData2 = new GraphData(g);

        ListScheduling listScheduling = new ListScheduling();

        int[] upperBoundAndLoadBalance = listScheduling.greedyAlgorithm(testGraphData1, _numOfP);
        //System.out.print(upperBoundAndLoadBalance[0] + "   " + upperBoundAndLoadBalance[1] +"\n");
        DFAlgorithmParallel test = new DFAlgorithmParallel(testGraphData2);
        Task[] finalResult = test.run(4, _numOfP, upperBoundAndLoadBalance[0], upperBoundAndLoadBalance[1]);

        for(int i = 0; i < finalResult.length; i++) {
            Node node = g.getNode(i);
            Task task = finalResult[i];

            node.setAttribute("Start", task.getStartTime());
            node.setAttribute("Processor", task.getProcessNum() + 1);
        }

        assertTrue(checker.checkValidity(g));
    }
}
